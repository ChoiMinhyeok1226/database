#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#pragma warning(disable : 4996)

void fileOpen(FILE** fp);
void filePrint(FILE* fp);
void fileFind(FILE* fp);
void fileDelete(FILE* fp, FILE* tempFile);
void fileUpdate(FILE* fp, FILE* tempFile);
void fileSave(FILE* fp, FILE* finalFile);
void fileClear(FILE** fp, const char* fileName);

int main() {
	char input;
	FILE* fp = NULL;
	FILE* temp1 = fopen("temp.txt", "w+");
	FILE* temp2 = fopen("temp2.txt", "w+");
	FILE* finalFile = NULL;
	int check = 0;
	char saveName[100];


	while (1) {
		printf("\n원하는 메뉴의 숫자를 입력해 주세요.\n");
		printf("1. FileLoad\n");
		printf("2. FilePrint\n");
		printf("3. FileUpdate\n");
		printf("4. FileDelete\n");
		printf("5. FileFind\n");
		printf("6. FileSave\n");
		printf("7. Exit\n");

		printf("\n입력 : ");
		scanf(" %c", &input);
		getchar();

		switch (input) {
		case '1':
			fileOpen(&fp);
			check = 0;
			break;
		case '2':
			if (check) {
				filePrint(temp1);//수정사항이 존재할 때는 수정된 내용을 출력
			}
			else {
				filePrint(fp);
			}
			break;
		case '3':
			if (check) { // 이미 temp 파일에 수정사항이 적용되어 있다면
				fileClear(&temp2, "temp2.txt"); // temp2 내용 삭제
				fileUpdate(temp1, temp2);

				fileClear(&temp1, "temp.txt"); // ? temp1을 완전히 비운 후
				fileSave(temp2, temp1);        // ? temp2 내용을 temp1에 저장
				temp1 = fopen("temp.txt", "r+"); // 다시 temp1을 열어 사용
			}
			else {
				fileUpdate(fp, temp1);
				fclose(temp1);
				temp1 = fopen("temp.txt", "r+");
				check = 1;
			}
			break;
		case '4':
			if (check) { // 이미 temp 파일에 수정사항이 적용되어 있다면
				fileClear(&temp2, "temp2.txt"); // temp2 내용 삭제
				fileDelete(temp1, temp2);

				fileClear(&temp1, "temp.txt"); // ? temp1을 완전히 비운 후
				fileSave(temp2, temp1);        // ? temp2 내용을 temp1에 저장
				temp1 = fopen("temp.txt", "r+"); // 다시 temp1을 열어 사용
			}
			else {
				fileDelete(fp, temp1);
				fclose(temp1);
				temp1 = fopen("temp.txt", "r+");
				check = 1;
			}
			break;

		case '5':
			fileFind(fp);
			break;
		case '6':
			printf("저장할 파일명을 입력해주세요.\n");
			scanf("%s", saveName);
			finalFile = fopen(saveName, "w+");
			if (check) {
				fileSave(temp1, finalFile);
			}
			else {
				fileSave(fp, finalFile);
			}
			break;
		case '7':
			printf("프로그램을 종료합니다.\n");
			if (fp != NULL) fclose(fp);
			if (temp1 != NULL) {
				fclose(temp1); // tempFile을 닫기
				remove("temp.txt"); // temp.txt 파일 삭제
			}
			if (temp2 != NULL) {
				fclose(temp2); // tempFile을 닫기
				remove("temp2.txt"); // temp.txt 파일 삭제
			}
			return 0;
		default:
			printf("올바른 숫자를 입력하세요.\n");
		}
	}
}

void fileOpen(FILE** fp) {
	printf("Load할 파일의 이름을 입력해주세요.\n");
	char fileName[100];
	scanf("%s", fileName);
	*fp = fopen(fileName, "r+");
	if (*fp == NULL) {
		printf("파일을 찾을 수 없습니다.\n");
	}
	else {
		printf("%s 파일이 정상적으로 Load 되었습니다.\n", fileName);
	}
}

void filePrint(FILE* fp) {
	char br[128];

	rewind(fp);
	printf("파일 내용을 출력합니다.\n\n");
	while (fgets(br, sizeof(br), fp) != NULL) {
		printf("%s\n", br);
	}
	printf("\n파일 출력이 종료되었습니다.\n");
}

void fileFind(FILE* fp) {
	char target[128];
	int currentPos = ftell(fp);

	printf("찾고자 하는 단어나 문장을 입력해 주세요.\n");
	fgets(target, sizeof(target), stdin);

	// 입력 받은 문장에서 새 줄 문자 제거
	size_t targetLen = strlen(target);
	if (target[targetLen - 1] == '\n') {
		target[targetLen - 1] = '\0';
	}

	targetLen = strlen(target);  // target의 길이 계산
	char* br = (char*)malloc(targetLen + 1);

	if (br == NULL) {
		printf("메모리 할당 실패\n");
		return;
	}

	rewind(fp);  // 파일 포인터를 처음으로 이동
	int found = 0;
	int seekNume = 0;

	// 파일을 한 줄씩 읽으면서 찾기
	while (fgets(br, targetLen + 1, fp)) {
		if (strstr(br, target) != NULL) {
			printf("찾은 내용: %s, 위치 %d\n", br, currentPos);
			found = 1;
		}
		fseek(fp, ++seekNume, SEEK_SET);
		currentPos = ftell(fp);
	}

	if (!found) {
		printf("찾는 내용이 없습니다.\n");
	}

	free(br);
}


void fileDelete(FILE* fp, FILE* tempFile) {
	char buffer[128];
	char target[128];

	printf("삭제할 단어나 문장을 입력해주세요.\n");
	fgets(target, sizeof(target), stdin);

	// 개행 문자 제거
	size_t targetLen = strlen(target);
	if (target[targetLen - 1] == '\n') {
		target[targetLen - 1] = '\0';
	}

	rewind(fp);

	int lineNum = 1;

	while (fgets(buffer, sizeof(buffer), fp)) {
		size_t bufferLen = strlen(buffer);
		if (buffer[bufferLen - 1] == '\n') {
			buffer[bufferLen - 1] = '\0';
		}

		char newBuffer[128] = "";  // 새로운 문자열을 저장할 공간
		char printBuffer[128] = ""; // 매 단계에서 변경된 줄을 저장할 공간
		char* start = buffer;
		char* pos;
		int modified = 0;  // 수정 여부 확인

		while ((pos = strstr(start, target)) != NULL) {
			if (!modified) {
				printf("\n[원본] (line %d): %s\n", lineNum, buffer);
				modified = 1;
			}

			printf("'%s' 을(를) 삭제할까요? (y/n): ", target);
			char choice;
			scanf(" %c", &choice);
			getchar();  // 개행 문자 처리

			if (choice == 'y' || choice == 'Y') {
				strncat(newBuffer, start, pos - start);  // 삭제할 부분 전까지 복사
			}
			else {
				strncat(newBuffer, start, pos - start + strlen(target));  // 삭제 안 하면 포함
			}

			// printBuffer를 즉시 업데이트
			strcpy(printBuffer, newBuffer);
			strcat(printBuffer, pos + strlen(target));

			// 변경된 줄을 출력
			printf("[변경된 줄]: %s\n", printBuffer);

			start = pos + strlen(target);  // 다음 위치로 이동
		}

		strcat(newBuffer, start);  // 마지막 남은 부분 추가

		// 삭제 후 빈 줄이 남아 있으면 저장하지 않음
		if (strlen(newBuffer) > 0) {
			fputs(newBuffer, tempFile);
			fputc('\n', tempFile);
		}
		lineNum++;
	}

	printf("삭제 작업이 완료되었습니다.\n");
}




void fileUpdate(FILE* fp, FILE* tempFile) {
	char buffer[128];
	char target[128];
	char updated[128];

	printf("수정할 단어나 문장을 입력해주세요.\n");
	fgets(target, sizeof(target), stdin);

	// 개행 문자 제거
	size_t targetLen = strlen(target);
	if (target[targetLen - 1] == '\n') {
		target[targetLen - 1] = '\0';
	}

	printf("'%s'에서 변경할 단어나 문장을 입력해 주세요.\n", target);
	fgets(updated, sizeof(updated), stdin);

	size_t updatedLen = strlen(updated);
	if (updated[updatedLen - 1] == '\n') {
		updated[updatedLen - 1] = '\0';
	}

	rewind(fp);

	int lineNum = 1;

	while (fgets(buffer, sizeof(buffer), fp)) {
		size_t bufferLen = strlen(buffer);
		if (buffer[bufferLen - 1] == '\n') {
			buffer[bufferLen - 1] = '\0';
		}

		char newBuffer[128] = "";  // 새로운 문자열을 저장할 공간
		char printBuffer[128] = ""; // 변경된 내용을 저장할 공간
		char* start = buffer;
		char* pos;
		int modified = 0;  // 수정 여부 확인

		while ((pos = strstr(start, target)) != NULL) {
			if (!modified) {
				printf("\n[원본] (line %d): %s\n", lineNum, buffer);
				modified = 1;
			}

			printf("'%s' 을(를) '%s'(으)로 변경할까요? (y/n): ", target, updated);
			char choice;
			scanf(" %c", &choice);
			getchar();  // 개행 문자 처리

			if (choice == 'y' || choice == 'Y') {
				strncat(newBuffer, start, pos - start);  // 변경할 부분 전까지 복사
				strcat(newBuffer, updated);  // 변경할 단어 추가
			}
			else {
				strncat(newBuffer, start, pos - start + strlen(target));  // 변경하지 않고 포함
			}

			// printBuffer를 즉시 업데이트
			strcpy(printBuffer, newBuffer);
			strcat(printBuffer, pos + strlen(target));

			// 변경된 줄을 출력
			printf("[변경된 줄]: %s\n", printBuffer);

			start = pos + strlen(target);  // 다음 위치로 이동
		}

		strcat(newBuffer, start);  // 마지막 남은 부분 추가

		// 빈 줄이 남아 있으면 저장하지 않음
		if (strlen(newBuffer) > 0) {
			fputs(newBuffer, tempFile);
			fputc('\n', tempFile);
		}
		lineNum++;
	}

	printf("변경 작업이 완료되었습니다.\n");
}






void fileSave(FILE* tempFile, FILE* finalFile) {
	char buffer[16];

	// 임시 파일을 처음으로 되돌리기
	rewind(tempFile);  // tempFile 포인터를 처음으로 되돌려서 파일의 시작으로 이동

	// 임시 파일에서 데이터를 읽어서 원본 파일에 저장
	while (fgets(buffer, sizeof(buffer), tempFile)) {
		// buffer 내용이 실제로 읽혔는지 확인
		if (strlen(buffer) > 0) {
			printf("읽은 라인: %s\n", buffer);
			if (fputs(buffer, finalFile) == EOF) {
				printf("파일에 쓰는 도중 오류가 발생했습니다.\n");
				break;
			}
		}
	}

	fclose(finalFile);  // 최종 파일 닫기
	printf("파일이 정상적으로 저장되었습니다.\n");
}

void fileClear(FILE** fp, const char* fileName) {
	if (*fp != NULL) {
		fclose(*fp);  // 기존 파일 닫기
	}

	*fp = fopen(fileName, "w+");  // "w" 모드로 다시 열기 (내용 삭제됨)
	if (*fp == NULL) {
		printf("파일을 초기화하는데 실패했습니다.\n");
	}
	else {
		printf("%s 파일의 모든 내용이 삭제되었습니다.\n", fileName);
	}
}

/*
현재 delete 수행과정
1. 함수 매개변수로 원본 파일과 temp 파일의 포인터를 전달
	temp 파일은 temp.txt이름으로 생성 고정
2. 원본 파일을 while문을 통해 순회하면서 삭제할 단어가 포함된 줄을 발견하면 해당 문장에서 삭제를 수행하고 그 내용을 temp 파일에 붙여넣기
3. 함수를 빠져나옴

여기서 문제 : 만약에 update와 delete가 save 함수를 거치기 전에 수행된다면 어떻게 해야하는가
1. 무조건 save를 거치게 한다.
2. 만약 temp 파일이 open  되어있다면 세 번째 파일 포인터를 생성하고 원본자리에 temp, temp자리에 세 번째 파일 포인터를 전달한다.
	이 경우에 함수 마지막 부분에 세 번째 파일의 내용을 temp에 덮어씌우는 과정이 필요(이 과정은 save 함수를 사용해도 될지도 모른다.)

*/
